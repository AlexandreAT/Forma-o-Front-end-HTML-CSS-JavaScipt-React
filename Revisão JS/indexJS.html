<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="/CSS Files/reviewJsStyle.css">
    <script src="/JS Files/reviewScript.js"></script>
    <script>
        console.log("teste log");
    </script>
    
    <title>Revisão JS</title>
</head>
<body>
    
    <main>

        <h1>Revisão JS</h1>

        <!-- <div class="div_revision">
            <h2></h2>
            <div class="revision_content">
                <p><span></span></p>
            </div>
        </div> -->

        <div class="div_revision">
            <h2>Tipos de dados</h2>
            <div class="revision_content">
                <p><span>Number: </span>Diferente de outras linguagens, aqui todo tipo de número é um number (o que seria float, double, etc. Aqui é simplesmente "number")</p>
                <p><span>Operações aritméticas: </span>As operações aritméticas são iguais em outras linguagens.</p>
                <p><span>Special Numbers: </span>São números especiais como Infinity e NaN.</p>
                <p><span>Strings: </span>As strings são como em outras linguagens, ex: "texto" 'texto'.</p>
                <p><span>Caracteres especiais: </span>Existem combinações de caracteres que tem efeitos especiais, como "\n" ou "\t".</p>
                <p><span>Concatenação: </span>É igual na maioria das linguagens: "teste" + " teste".</p>
                <p><span>Interpolação: </span>É igual na maioria das linguagens e semelhante a concatenação, precisa de crase para funcionar: `teste: ${2 + 2}`</p>
                <p><span>Booleans: </span>Igual em outras linguagens, represena o valor falso e verdadeiro.</p>
                <p><span>Comparações: </span>Semelhante a maioria das linguagens: igual (==), maior e menor (> e < ou >= e <=), diferente (!=), idêntico (===), diferente (!===).</p>
                <p><span>Operadores lógicos: </span>Igual as outras linguagens: && (and), || (or), ! (not)</p>
                <p><span>Empty values: </span>Semelhante as outras linguagens: null e undefined.</p>
                <p><span>Conversão de tipo: </span>Algumas conversões acontecem sem percebermos, e podem dar resultados incoerentes, como: 5 * null = 0, "5" - 3 = 2, "5" + 1 = 51, "a" * "b" = NaN</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>Estruturas de programação</h2>
            <div class="revision_content">
                <p><span>var: </span>Não costuma ser muito usado por ser muito genérico.</p>
                <p><span>let: </span>O tipo mais usado de variavel.</p>
                <p><span>const: </span>É uma variavel constante, logo ela não deve mudar.</p>
                <p><span>math: </span>Função muito utilizada para operações matemáticas.</p>
                <p><span>console: </span>Função muito utilizada para exibir algumas mensagens no console.</p>
                <p><span>if e else: </span>Tem as mesmas funções de outras linguagens, são estruturas de controle.</p>
                <p><span>while e for: </span>Tem as mesmas funções de outras linguagens, São estruturas de repetição.</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>Funções</h2>
            <div class="revision_content">
                <p><span>Definindo uma função: </span>É igual na maioria das linguagens: function minhaFunção(){ return; };</p>
                <p><span>Arrow function: </span>É uma sintaxe resumida para criação de funções: const arrowFunction = () => { return; };</p>
                <p><span>Arrow function resumida: </span>const arrowFunction = (x) => x * x;</p>
                <p><span>Closure: </span>São basicamente funções uma dentro da outra.</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>Vetores e Objetos</h2>
            <div class="revision_content">
                <p><span>Arrays: </span>É igual na maioria das linguagens: let lista = [1, 2, 3, 4, 5]</p>
                <p><span>Métodos: </span>É igual em outras linguagens: lista.length</p>
                <p><span>Objetos: </span>É igual em outras linguagens: const person = { name: "Mateus", age: 31, job: "Programador" }</p>
                <div class="list">
                    <p><span>Alguns comandos:</span></p>
                        <ul>
                            <li>Adicionando e deletando propriedades de obj: obj.propriedadeNova = 1; delete obj.propriedadeNova;</li>
                            <li>Copiando as propriedades de um obj para o outro: Object.assign(objCopy, objOriginal);</li>
                            <li>Verificando as propriedades de um objeto: Object.keys(obj);</li>
                            <li>Verificando as prop e valores de um objeto: Object.entries(obj);</li>
                        </ul>
                </div>    
                <p><span>Mutação: </span>É como um atalho de outro objeto, ele esta refereciando aquele objeto, ou seja se mudarmos algo em um desses objetos, o outro também tera a modificação: const objReferencia = objOriginal;</p>
                <p><span>Push e Pop: </span>São usados para adicionar e remover itens do array: const vet = [a, b]; vet.push("c", "d", "e"); vet.pop();</p>
                <p><span>Unshift e Shift: </span>Iguais ao Push e Pop, mas aqui eles trabalham com o priemiro valor do array, Unshift adiciona um elemento e Shift deleta um elemento na primeira posição.</p>
                <p><span>IndexOf e lasIndexOf: </span>Iguais em outras linguagens, são usados para conseguir a posição de um elemento, IndexOf vê do inicio ao fim, e lastIndexOf vê do fim ao início: const vet = ["morando", "maçã", "abacate"]; indexOf("maçã"); lasIndexOf("abacate");</p>
                <p><span>slice: </span>Igual em outras linguagens, é usado para extrair um array de outro array, colocando a posição inicial que você quer extrair até a final: const array = ["a", "b", "c", "d", "e"]; const subArray = array.slice(2, 4);</p>
                <p><span>forEach: </span>Igual em outras linguagens, percorre um array até acabar todos os elementos dele e realizando alguma função em cada elemento: const nums = [1, 2, 3, 4, 5]; nums.forEach((numero) => { console.log("O número é: "+ numero) })</p>
                <p><span>for...of</span>É uma estrutura de repetição parecida com o for e forEach, o número de repetição é baseado no array utilizado: let total = 0; for(num of total){ total += num; } return total;</p>
                <p><span>includes: </span>Verifica se o array tem elemento: const brands = ["BMW", "VW", "Fiat"]; brands.includes("Fiat");</p>
                <p><span>reverse: </span>Inverte os elementos de um array: vet.reverse();</p>
                <p><span>destructuring: </span>Nos permite desestruturas algum dado, separando ele em várias variaveis sem precisar declarar elas e ficar acessando os indices do vetor: const userDetails = { name: Alexandre, lasName: Teizen, job: Programador } const {name, latName, job} = userDetails; const {name: primeiroNome} = userDetails;</p>
                <p><span>destructuring em arrays: </span>É igual ao anterior usado em objetos, mas com algumas mudanças na sintaxe: const myList = ["Avião", "Moto", "Carro"]; const [aviao, moto, carro] = myList;</p>
                <span>Strings:</span>
                <p><span>trim: </span>Remove todos os caracteres especiais e espaços em branco, deixando apenas o texto puro: stringTeste.trim();</p>
                <p><span>padStart e padEnd: </span> padStar insere um testo no começo da string, padEnd insere um texto no final da string: const num = "1"; const newNumber = num.padStart(4, "0"); // Adiciona 4 zeros.</p>
                <p><span>split: </span>Divide a string em um array utilizando um separador: const string = "Teste, string"; const newString = string.split(",");</p>
                <p><span>Join: </span>O contrário do split, une um array em uma string utilizando um separador: newString.join(",");</p>
                <p><span>repeat: </span>Repete um texto n vezes: string.repeat(5);</p>
                <span>Function: </span>
                <p><span>Rest Operator: </span>É utilizado para receber indefinidos argumentos em uma função: const somaInfinita = (...args) => { let total = 0; for(let i=0; i <= args.length; i++){ total += args[i]; } return total; } // Aqui podemos adicionar quantos argumentos quiser.</p>
                <p><span>Comunicação com a API: </span></p>
                <p><span>JSON: </span>É utilizado em uma comunicação entre a API e o front-end, é muito utilizado no dia a dia (algumas regras: Usa apenas aspas duplas e não aceita comentários): const myJSon = '{"name": "Alexandre", "age": 22, "skills": ["front-end", "back-end", "banco de dados"]}';</p>
                <p><span>Conversão de JSon: </span>Na maioria das vezes é necessário converter o JSon, pois não conseguimos utilizar o dado daquela maneira, em texto puro, e não conseguimos enviar ele para uma API naquele formato, precisamos enviar um JSon para a API, e recber um object em nosso front-end com JavaScript, para isso usamos o objeto JSON: const myObject = JSON.parse(myJSon); // Agora o JSon myJSon virou um objeto normal myObject</p>
                <p><span>Conversão do object para JSon: </span>const myNewJson = JSON.stringify(myObject); // Esse myObject agora se torna um JSon e vai ser enviado para a API em formato de texto.</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>POO</h2>
            <div class="revision_content">
                <p><span>Paradigma de programação: </span>O paradigma é basicamente um jeito de programar, aqui falamos de POO (programação orientada a objetos), aqui POO é a mesma coisa que em outras linguagens, mas com diferenças de sintaxe, aqui vamos mostrar de forma gradual a evolução do JS até como usamos objetos e classes hoje em dia.</p>
                <p><span>Métodos: </span>São basicamentes as funções dentro dos objetos.</p>
                <p><span>this: </span>É usado para referenciar o próprio objeto: const userInfo = {name: "Alexandre", getNome: function () {return this.name}};</p>
                <p><span>Prototype: </span>É um recurso que faz parte da arquitetura do JS, é uma espécie de herança onde o objetos pais herdam propriedades e métodos aos filhos, isso é feito de forma oculta sem percebermos.</p>
                <p><span>Prototype - fallback: </span>Quando uma propriedade não existe em um objeto, ela é procurada no seu ancestral, caso ache a propriedade ele busca o resultado dela.</p>
                <p><span>Prototype - conceito: </span>Quando criamos um objeto a partir de outro, aquele objeto na verdade é um prototype do objeto pai, ele herda todas as características do prototype dele (por exemplo se for um object ele herda tudo de object), e também herda tudo de seu objeto pai.</p>
                <p><span>Classes: </span>É igual em outras linguagens, basiamente cria um objeto a partir de outro (uma classe): const cachorro = { raca:  null, patas = 4, }; const pastorAlemao = Object.create(cachorro); pastorAlemao.raca = "Pastor Alemão";</p>
                <p><span>Função construtora: </span>É igual em outras linguagens, serve para se iniciar o objeto passando os dados necessários: function criarCachorro(nome, raca){ const cachorro = Object.creat({}); cachorro.nome = nome; cachorro.raca = raca; return cachorro }; const bob = criarCachorro("Bob", "Vira lata");</p>
                <p><span>Funções com Classe: </span>É o conceito e a forma de se criar objetos que atualiza essas formas antigas, se aproximando mais das outras linguagens, utilizando uma sintaxe diferente dessas mostradas anteriormente: function Cachorro(nome, raca){ this.nome = nome; this.raca = raca; }; const husky = new Cachorro("Ozzy", "Husky");</p>
                <p><span>Classes de função com métodos: </span>Para adicionar métodos antes da criação do obejeto, podemos acessar o prototype e colocá-los lá: Cachorro.prototype.uivar = function() { console.log("Auuu"); }</p>
                <p><span>Classes ES6: </span>São os métodos atuais de se utilizar as classes, aqui é o mais próximo de outras linguagens que temos hoje em dia: class CachorroClasse{ construtor(nome, raca){this.nome = nome; this.raca = raca;} } const jeff = new CachorroClasse("Jeff", "Labrador");</p>
                <p><span>Symbol: </span>É usado para criar propriedade únicas e imutaveis: class Aviao{constructor(marca, turbina){ this.marca = marca; this.turbina = turbina; }}; const asas = Symbol(); Aviao.prototype[asas] = 2; // Com isso a classe passa esse valor para todos os objetos, e é impossível alterar ele.</p>
                <p><span>Getter e Setters: </span>É igual em outras linguagens, segue a mesma ideia, Get é usado para pegar ou exbir os valores das propriedades, e o Set é usado para setar ou alterar os valores das propriedades: class Post{constructor(titulo, descricao, tags){ this.titulo = titulo; this.descricao = descricao; this.tags = tags } get exibirTitulo(){return "Você esta lendo: "+ this.titulo;} set adicionarTags(tags){ const tagsArray = tags.split(", "); this.tags = tagsArray; }} const myPost = new Post("Algum post", "É um post sobre programar."); console.log(myPost.exibirTitulo); myPost.adicionarTags = "progrmacao, javaScript, JS"; console.log(myPost);</p>
                <p><span>Herança: </span>É praticamente igual a outras linguagens, uma classe extend a outra: class Mamifero{constructor(patas){this.patas = patas}}; class Lobo extends Mamifero{constructor(patas, nome){ super(patas patas); this.nome = nome; }}</p>
                <p><span>instanceof: </span>É usado para verificar se um objeto é pai do outro: const loboBranco = new Lobo(4, "Lobo Branco"); console.log(loboBranco instanceof Lobo);</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>Depuração</h2>
            <div class="revision_content">
                <p><span>debug: </span>Método para encontrar e resolver bugs em um código.</p>
                <p><span>stric: </span>É usado para deixar o JS mais rigoroso, com o objetivo de evitar esses bugs, ele deve ser declarado no topo do arquivo de funções: "use strict";</p>
                <p><span>debugger: </span>É uma instrução que nos permite realizar o debug no console do navegador, ele pausa a execução na linha em que é utilizado: debugger;</p>
                <p><span>exceptions: </span>São os erros que nós geramos no programa, ele faz com que o programa seja abortado: throw new Error("Mensagem de erro.");</p>
                <p><span>try catch: </span>É igual na maioria das linguagens de programação, segue os mesmos conceitos: try{  } catch(error){ console.log("Mensagem de erro."); }</p>
                <p><span>finally: </span>É uma instrução que vai após o bloco try catch, ela é executada independente se tiver erro ou não: try{  } catch(error){ console.log("Mensagem de erro."); } finally{ console.log("O código foi executado!"); }</p>
                <p><span>assertions: </span>É quando quandos os tratamentos passados pelo usuário gera um erro.</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>Programação assíncrona</h2>
            <div class="revision_content">
                <p><span>Conceito: </span>Na programação assíncrona as execuções não travam o programa, ou seja, uma função pode estar rodando enquanto usamos o programa normalmente.</p>
                <p><span>setTimeout: </span>Com essa função estabelecemos uma ação para ser executada após certo tempo: setTimeout(function(){ console.log("Mensagem após 2 segundos"); }, 2000);</p>
                <p><span>setInterval: </span>É utilizada para executar algo a cada intervalo de tempo, como um looping infinito: setInterval(function(){ console.log("Mensagem em um intervado de 3 segundos."); }, 3000)</p>
                <p><span>promises: </span>As "promessas" são basicamente valores que podem chegar em um futuro, para isso usamos o objeto Promise, com isso podemos executar certos comando no final do código: const promessa = Promise.resolve(5 + 5); console.log("Msg antes da promise"); promessa.then((value) => { console.log("A soma é "+ value); })</p>
                <p><span>reject: </span>Usamos quando queremos rejeitar algum possível dado da promise: function checkNumber(n){ return new Promise((resolve, reject) => { if(n > 10){resolve("O número é maior que 10");} else{reject(new Error("Número muito baixo"));} }) }</p>
                <p><span>all: </span>É utilizado para resolvermos mais de uma promise, resolvendo promessas em conjunto: Promise.all([p1, p2, p3]).then((values) => console.log(values))</p>
                <p><span>async functions: </span>São funções que retornam promise, é um pouco mais comum que utilizar as promise: async function somarComDelay(a, b){ return a+b; } somarComDelay(2, 4).then((value) => { console.log("O valor da soma é: "+ value); })</p>
                <p><span>await: </span>O await só é válido em funções async, serve para aguardar o resultado de uma async function, simplificando a maneira de lidar com esse tipo de função, assim não precisamos trabalhar diretamente com a promise: function resolveComDelay(){ return new Promise((resolve) => { setTimeout(() => { resolve("Resolveu a promise"); }, 2000); }) } async function chamadaAsync(){ console.log("Chamando a promise, e esperando o resultado"); const result = await resolveComDelay(); console.log("O resultado chegou: "+ result); }</p>
                <p><span>Generators: </span>Funciona de forma semelhante as promise, as ações podem ser pausadas e continuadas depois: function* generator(){ yield 1; yield 2; yield 3; } const gen = generator(); console.log(gen.next().value); console.log(gen.next().value); console.log(gen.next().value);</p>
            </div>
        </div>

        <div class="div_revision">
            <h2>JS e o navegador</h2>
        </div>
</body>
</html>