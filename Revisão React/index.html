<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/CSS Files/reviewJsStyle.css">
    <script src="/JS Files/reviewScript.js" defer></script>

    <title>Revisão React</title>
</head>
<body>
    <main>
        <h1>Revisão React</h1>

        <div class="div_revision">
            <h2>Conceitos</h2>
            <div class="revision_content">
                <p><span>O que é:</span> React é um biblioteca javascript para desenvolver aplicações front-end, a categoria desses projetos é chamada de SPA (single page application), isso quer dizer que todas as mudanças de estado das páginas são baseadas em eventos de um único HTML. A arquitetura do react é baseado em componentes, onde tudo pode se tornar um componente.</p>
                <p><span>Vite: </span>É a maneira de criar aplicações em React: npm crate vite@latest</p>
                <h3>Estrutura base do React</h3>
                <p><span>node_modules: </span>É onde ficam as dependências do projeto.</p>
                <p><span>public: </span>É uma pasta de assets e arquivos estáticos, como algumas imagens e ícones (porém a public não costuma ser muito utilizada, ao contrário do src).</p>
                <p><span>src: </span>É onde escrevemos o código da aplicação, ou seja é a pasta que a gente mais meche.</p>
                <p><span>src/main.jsx: </span>É o arquivo principal da aplicação, ele que inicializa tudo, é um arquivo que não mechemos tantos, mas um exemplo seria quando temos várias páginas, as rotas acabam sendo configuradas lá.</p>
                <p><span>src/App.jsx: </span>É o componente principal da aplicação.</p>
                <h3>Fundamentos do React</h3>
                <p><span>components: </span>Devemos crias os componentes dentro de uma pasta chamada components, que criamos no src. Os componentes devem ser nomeados em CamelCase. Devemos utilizar a extensão ".jsx" no componente criado, pois facilita a formatação para os editores. Dentro do componente precisamos criar e exportar uma função.</p>
                <p><span>Importando componentes: </span>Para usar o componente precisamos importar ele, por exemplo: import X from./components/X.jsx (sendo X o nome do componente). Podemos incluir um componente dentro de outro, para isso podemos apenas chamar o componente como se fosse uma tag HTML: &lt;FirstComponent/&gt; </p>
                <p><span>JSX: </span>O JSX é o HTML do react, ele fica dentro do return, e tudo o que fica fora do return são as funções. Existem diferenças entre esse HTML e o HTML convencional, pois todos os termos (de HTML e JS) que coincidem, acabam sendo trocados (no caso o HTML que troca), por exemplo: O "class" do HTML vira "className", isso acontece pois dentro do próprio JSX, nós podemos inserir código de javascript: {2 + 2}.</p>
                <p><span>Hierarquia: </span>Podemos criar uma hierarquia de componentes, chamando um componente dentro do outro, assim quando chamamos o componente pai todos os outros vem junto.</p>
                <p><span>Eventos: </span>Em react temos os mesmo eventos de JS, mas de forma mais simples, no react nós podemos adicionar o evento na própria tag do HTML, como se fosse um atributo, porém aqui no react chamamos de propriedade: &lt;button onClick = {() =&gt; console.log("Testando um evento")}&gt;Clique aqui&lt;/button&gt;. Porém o mais recomendado é não fazer dessa maneira, e colocar os eventos utilizando funções criadas fora do JSX (HTML): onClick={FuncaoDeClick}</p>
            </div>
            <h2>Conceitos avançados</h2>
            <div class="revision_content">
                <p><span>Imagens: </span>As imagens normalmente ficam na pasta public ou nos assets da pasta src. Mesmo que steja na pasta public, nós podemos chamas as imagens de maneira simplificada pois a pasta public esta linkada com o src: &lt;img src="/img.jpg" alt="Alguma imagem" /&gt;. Porém a forma mais utilizada é deixar a imagem na pasta assets do src, assim importamos ela como se ela fosse um componente: &lt;img src={night} alt="Outra imagem" /&gt;</p>
                <p><span>hooks: </span>São recursos do react que tem diversas funções, como guardar ou alterar o estado de algum dado. Eles também precisam ser importados e sempre começam com a palavra "use", como "useState" ou "useEffect".</p>
                <p><span>useState: </span>É um dos hooks mais utilizados, podemos gerenciar o estado de um ou mais dados, como se fosse um getter e setter: const [anotherNumber, setAnotherNumber] = useState(15); &lt;button onClick={() => setAnotherNumber(20)}&gt;&lt;/button&gt;.</p>
                <p><span>map: </span>Dados do tipo array (vetores) são muito comuns em aplicações, como array de objetos, para renderizar esses elementos usamos o método "map", é possível inserir JSX na execução: &lt;ul> {list.map((item) => ( &lt;li>{item}&lt;/li> ))} &lt;/ul></p>
                <p><span>key: </span>A propriedade key é a chave única do elemento, cada item da lista (array) deve ter uma chave única, isso ajuda a renderizar o componente: &lt;li key={user.id}> {user.name} - {user.age} anos &lt;/li></p>
                <p><span>Previus state: </span>É um recurso do hook useState onde pegamos o valor original para fazer alguma alteração: setUsers((prevUsers) => prevUsers.filter((user) => randomNumber !== user.id));</p>
                <p><span>Renderização condicional: </span>É basicamente um if no JSX, renderizamos uma parte do template por meio de uma condição: const x = 5; {x > 2 && &lt;p>Isso será exibido&lt;/p>};</p>
                <p><span>Adicionando um else: </span>Quando usamos um else na renderização condicional a estrutura acaba mudando um pouco: {name === "João" ?(&lt;div> &lt;p>Olá joão!&lt;/p> &lt;/div>) : ( &lt;div> &lt;p>Nome não encontrado!&lt;/p> &lt;/div> )}</p>
                <p><span>Props: </span>As props que permitem a passagem de dados de um componente pai para um componente filho, são úteis para quando houver dados vindo de um banco de dados. Elas vem em um objeto no argumento da função: export const ShowUserName = (props) => { return ( &lt;div>&lt;h3>O nome do usuário é: {props.name}&lt;/h3>&lt;/div> ) } &lt;ShowUserName name="Alexandre"/></p>
                <p><span>Desestruturando props: </span>Os componentes geralmente tem mais de uma prop, então podemo facilitar o uso delas desetruturando no parâmetro da função do componente. Assim facilitamos a sintaxe: export const CarDetails = ({brand, km, color}) => {... &lt;CarDetails brand="Ford" km={1000} color="Verde"/></p>
                <p><span>Reutilização de componentes: </span>Com o auxilio das props podemos reutilizar os componentes de forma que faça mais sentido, pois podemos apenas chamar o componente com as propriedades, e passar valores diferentes para elas.</p>
                <p><span>Reutilização com loop: </span>Os arrays podem ter muitos itens/objetos, e as vezes nem sabemos a quantidade certa, então o correto é utilizar estruturas de loop para percorres os itens, assim unimos alguns dos conceitos e ferramentas descritas até aqui: {cars.map((car) => ( &lt;CarDetails key={car.id} brand={car.brand} color={car.color} km={car.km}/> ))}</p>
                <p><span>Fragments: </span>São interessantes para quando há mais de um elemento pai no componente, ou quando não queremos incluir HTML desnecessário no elemento pai, não alterando sua estrutura, para usar o fragment basta colocar todo o código entre &lt;>...&lt;/>.</p>
                <p><span>Children prop: </span>É utilizando quando um componente precisa ter JSX dentro dele: export const Container = ({children}) => { return ( &lt;div>&lt;h3>Conteúdo do componente pai: &lt;/h3> {children}&lt;/div> ) }</p>
                <p><span>Funções em prop: </span>Poemos passar funções através de props, criando a função no componente pai e enviando como prop, no componente filho podemos utilizar para algum evento: export const ExecuteFunction = ({myFunction}) => { return ( &lt;div>&lt;button onClick={myFunction}>Clique em mim&lt;/button>&lt;/div> ) }</p>
                <p><span>state lift: </span>É um termo de quando um valor é levado do componente filho para o pai, ou seja o caminho inverso da props. Geralmente temos um componente que usa o state e outro que altera (aqui o componente filho pode realizar alguma ação que altera algo no componente pai).</p>
            </div>
            <h2>CSS no React</h2>
            <div class="revision_content">
                <p><span>CSS Global: </span>Utilizamos um arquivo global para aplicar estilos padrões em todos os componentes, mas além dele temos os arquivos principais de cada componente.</p>
                <p><span>CSS do componente: </span>O CSS do componente normalmente tem o mesmo nome do componente em si, podemos estilizar normalmente aquele componente mas devemos importar o arquivo de CSS dentro dele. Os arquivos de CSS podem VAZAR, ou seja, se estilizarmos uma tag "p" no css de um componente, essa estilização pode vazar para outros componentes, então devemos ficar espertos com isso e utilizar as classes ou ids.</p>
                <p><span>Inline style dinâmico: </span>É uma técnica onde aplicamos um estilo baseado em uma condição, como podemos colocar o javascript junto do JSX, podemos criar um if ternário e usarmos isso com o CSS: &lt;p style={n > 10 ? {color: "red"} : {color: "magenta"}}>CSS dinâmico!</p></p>
                <p><span>Classes dinâmicas: </span>Podemos também aplicar uma lógica para adicionar classes a um elemento, assim podemos estilizar e controlar a classe em um arquivo, ou seja, é melhor que o inline do CSS: &lt;p className={redTitle ? "red-title" : "title"}>Este título tem uma classe.</p></p>
                <p><span>CSS Modules: </span>É outra forma de estilizar as aplicações de react. É normalmente o que a gente quer com uma aplicação em react, pois com isso podemos deixar o CSS "scoped", ou seja, sem vazar para outros componentes.</p>
            </div>
            <h2>Formulários e React</h2>
            <div class="revision_content">
                <p><span>Label envolvendo o input: </span>É comum em react envolvermos um input em uma label, facilitando a semântica do código: &lt;label> &lt;span>E-mail: &lt;/span>&lt;input type="text" name="email" placeholder="Digite o seu email" />&lt;/label></p>
                <p><span>Manipulando os valores: </span>Para isso, aqui também vamos usar o useState, ou serja, armazenamos os valores com o set. Para isso usamos uma função no "artibuto" onChange, a função deve usar o useState para atualizar o valor do state.</p>
                <p><span>Simplificando a manipulação: </span>Podemos criar uma função inline dentro do onChange, para trocar o valor do dado de forma mais simples: &lt;span>E-mail: &lt;/span>&lt;input type="text" name="email" placeholder="Digite o seu email" onChange={(e) => setEmail(e.target.value)} /></p>
                <p><span>Controlled inputs: </span>Podemos atribuir valores pré-existentes aos inputs dos formulários: </p>
            </div>
        </div>
    </main>
</body>
</html>