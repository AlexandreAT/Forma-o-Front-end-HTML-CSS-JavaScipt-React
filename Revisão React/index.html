<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/CSS Files/reviewReactStyle.css">

    <title>Revisão React</title>
</head>
<body>
    <main>
        <h1>Revisão React</h1>

        <div class="div_revision">
            <h2>Conceitos</h2>
            <div class="revision_content">
                <p><span>O que é:</span> React é um biblioteca javascript para desenvolver aplicações front-end, a categoria desses projetos é chamada de SPA (single page application), isso quer dizer que todas as mudanças de estado das páginas são baseadas em eventos de um único HTML. A arquitetura do react é baseado em componentes, onde tudo pode se tornar um componente.</p>
                <p><span>Vite: </span>É a maneira de criar aplicações em React: <span class="cd">npm crate vite@latest</span>. Seguimos com as configurações direto pelo terminal, e após isso precisamos iniciar a aplicação em react: <span class="cd">npm run dev</span></p>
                <h3>Estrutura base do React</h3>
                <p><span>node_modules: </span>É onde ficam as dependências do projeto.</p>
                <p><span>public: </span>É uma pasta de assets e arquivos estáticos, como algumas imagens e ícones (porém a public não costuma ser muito utilizada, ao contrário do src).</p>
                <p><span>src: </span>É onde escrevemos o código da aplicação, ou seja é a pasta que a gente mais meche.</p>
                <p><span>src/main.jsx: </span>É o arquivo principal da aplicação, ele que inicializa tudo, é um arquivo que não mechemos tantos, mas um exemplo seria quando temos várias páginas, as rotas acabam sendo configuradas lá.</p>
                <p><span>src/App.jsx: </span>É o componente principal da aplicação.</p>
                <h3>Fundamentos do React</h3>
                <p><span>components: </span>Devemos crias os componentes dentro de uma pasta chamada components, que criamos no src. Os componentes devem ser nomeados em CamelCase. Devemos utilizar a extensão ".jsx" no componente criado, pois facilita a formatação para os editores. Dentro do componente precisamos criar e exportar uma função.</p>
                <p><span>Importando componentes: </span>Para usar o componente precisamos importar ele, por exemplo: import X from./components/X.jsx (sendo X o nome do componente). Podemos incluir um componente dentro de outro, para isso podemos apenas chamar o componente como se fosse uma tag HTML: <span class="cd">&lt;FirstComponent/&gt;</span> </p>
                <p><span>JSX: </span>O JSX é o HTML do react, ele fica dentro do return, e tudo o que fica fora do return são as funções. Existem diferenças entre esse HTML e o HTML convencional, pois todos os termos (de HTML e JS) que coincidem, acabam sendo trocados (no caso o HTML que troca), por exemplo: O "class" do HTML vira "className", isso acontece pois dentro do próprio JSX, nós podemos inserir código de javascript: <span class="cd">{2 + 2}</span>.</p>
                <p><span>Hierarquia: </span>Podemos criar uma hierarquia de componentes, chamando um componente dentro do outro, assim quando chamamos o componente pai todos os outros vem junto.</p>
                <p><span>Eventos: </span>Em react temos os mesmo eventos de JS, mas de forma mais simples, no react nós podemos adicionar o evento na própria tag do HTML, como se fosse um atributo, porém aqui no react chamamos de propriedade: &lt;button onClick = {() =&gt; console.log("Testando um evento")}&gt;Clique aqui&lt;/button&gt;. Porém o mais recomendado é não fazer dessa maneira, e colocar os eventos utilizando funções criadas fora do JSX (HTML): <span class="cd">onClick={FuncaoDeClick}</span></p>
            </div>
            <h2>Conceitos avançados</h2>
            <div class="revision_content">
                <p><span>Imagens: </span>As imagens normalmente ficam na pasta public ou nos assets da pasta src. Mesmo que steja na pasta public, nós podemos chamas as imagens de maneira simplificada pois a pasta public esta linkada com o src: <span class="cd">&lt;img src="/img.jpg" alt="Alguma imagem" /&gt;. Porém a forma mais utilizada é deixar a imagem na pasta assets do src, assim importamos ela como se ela fosse um componente: &lt;img src={night} alt="Outra imagem" /&gt;</span></p>
                <p><span>hooks: </span>São recursos do react que tem diversas funções, como guardar ou alterar o estado de algum dado. Eles também precisam ser importados e sempre começam com a palavra "use", como "useState" ou "useEffect".</p>
                <p><span>useState: </span>É um dos hooks mais utilizados, podemos gerenciar o estado de um ou mais dados, como se fosse um getter e setter: <span class="cd">const [anotherNumber, setAnotherNumber] = useState(15); &lt;button onClick={() => setAnotherNumber(20)}&gt;&lt;/button&gt;.</span></p>
                <p><span>map: </span>Dados do tipo array (vetores) são muito comuns em aplicações, como array de objetos, para renderizar esses elementos usamos o método "map", é possível inserir JSX na execução: <span class="cd">&lt;ul> {list.map((item) => ( &lt;li>{item}&lt;/li> ))} &lt;/ul></span></p>
                <p><span>key: </span>A propriedade key é a chave única do elemento, cada item da lista (array) deve ter uma chave única, isso ajuda a renderizar o componente: <span class="cd">&lt;li key={user.id}> {user.name} - {user.age} anos &lt;/li></span></p>
                <p><span>Previus state: </span>É um recurso do hook useState onde pegamos o valor original para fazer alguma alteração: <span class="cd">setUsers((prevUsers) => prevUsers.filter((user) => randomNumber !== user.id));</span></p>
                <p><span>Renderização condicional: </span>É basicamente um if no JSX, renderizamos uma parte do template por meio de uma condição: <span class="cd">const x = 5; {x > 2 && &lt;p>Isso será exibido&lt;/p>};</span></p>
                <p><span>Adicionando um else: </span>Quando usamos um else na renderização condicional a estrutura acaba mudando um pouco: <span class="cd">{name === "João" ?(&lt;div> &lt;p>Olá joão!&lt;/p> &lt;/div>) : ( &lt;div> &lt;p>Nome não encontrado!&lt;/p> &lt;/div> )}</span></p>
                <p><span>Props: </span>As props que permitem a passagem de dados de um componente pai para um componente filho, são úteis para quando houver dados vindo de um banco de dados. Elas vem em um objeto no argumento da função: <span class="cd">export const ShowUserName = (props) => { return ( &lt;div>&lt;h3>O nome do usuário é: {props.name}&lt;/h3>&lt;/div> ) } &lt;ShowUserName name="Alexandre"/></span></p>
                <p><span>Desestruturando props: </span>Os componentes geralmente tem mais de uma prop, então podemo facilitar o uso delas desetruturando no parâmetro da função do componente. Assim facilitamos a sintaxe: <span class="cd">export const CarDetails = ({brand, km, color}) => {... &lt;CarDetails brand="Ford" km={1000} color="Verde"/></span></p>
                <p><span>Reutilização de componentes: </span>Com o auxilio das props podemos reutilizar os componentes de forma que faça mais sentido, pois podemos apenas chamar o componente com as propriedades, e passar valores diferentes para elas.</p>
                <p><span>Reutilização com loop: </span>Os arrays podem ter muitos itens/objetos, e as vezes nem sabemos a quantidade certa, então o correto é utilizar estruturas de loop para percorres os itens, assim unimos alguns dos conceitos e ferramentas descritas até aqui: <span class="cd">{cars.map((car) => ( &lt;CarDetails key={car.id} brand={car.brand} color={car.color} km={car.km}/> ))}</span></p>
                <p><span>Fragments: </span>São interessantes para quando há mais de um elemento pai no componente, ou quando não queremos incluir HTML desnecessário no elemento pai, não alterando sua estrutura, para usar o fragment basta colocar todo o código entre &lt;>...&lt;/>.</p>
                <p><span>Children prop: </span>É utilizando quando um componente precisa ter JSX dentro dele: export const Container = ({children}) => { return ( &lt;div>&lt;h3>Conteúdo do componente pai: <span class="cd">&lt;/h3> {children}&lt;/div> ) }</span></p>
                <p><span>Funções em prop: </span>Poemos passar funções através de props, criando a função no componente pai e enviando como prop, no componente filho podemos utilizar para algum evento: <span class="cd">export const ExecuteFunction = ({myFunction}) => { return ( &lt;div>&lt;button onClick={myFunction}>Clique em mim&lt;/button>&lt;/div> ) }</span></p>
                <p><span>state lift: </span>É um termo de quando um valor é levado do componente filho para o pai, ou seja o caminho inverso da props. Geralmente temos um componente que usa o state e outro que altera (aqui o componente filho pode realizar alguma ação que altera algo no componente pai).</p>
            </div>
            <h2>CSS no React</h2>
            <div class="revision_content">
                <p><span>CSS Global: </span>Utilizamos um arquivo global para aplicar estilos padrões em todos os componentes, mas além dele temos os arquivos principais de cada componente.</p>
                <p><span>CSS do componente: </span>O CSS do componente normalmente tem o mesmo nome do componente em si, podemos estilizar normalmente aquele componente mas devemos importar o arquivo de CSS dentro dele. Os arquivos de CSS podem VAZAR, ou seja, se estilizarmos uma tag "p" no css de um componente, essa estilização pode vazar para outros componentes, então devemos ficar espertos com isso e utilizar as classes ou ids.</p>
                <p><span>Inline style dinâmico: </span>É uma técnica onde aplicamos um estilo baseado em uma condição, como podemos colocar o javascript junto do JSX, podemos criar um if ternário e usarmos isso com o CSS: <span class="cd">&lt;p style={n > 10 ? {color: "red"} : {color: "magenta"}}>CSS dinâmico!&lt;/p></span></p>
                <p><span>Classes dinâmicas: </span>Podemos também aplicar uma lógica para adicionar classes a um elemento, assim podemos estilizar e controlar a classe em um arquivo, ou seja, é melhor que o inline do CSS: <span class="cd">&lt;p className={redTitle ? "red-title" : "title"}>Este título tem uma classe.&lt;/p></span></p>
                <p><span>CSS Modules: </span>É outra forma de estilizar as aplicações de react. É normalmente o que a gente quer com uma aplicação em react, pois com isso podemos deixar o CSS "scoped", ou seja, sem vazar para outros componentes.</p>
            </div>
            <h2>Formulários e React</h2>
            <div class="revision_content">
                <p><span>Label envolvendo o input: </span>É comum em react envolvermos um input em uma label, facilitando a semântica do código: <span class="cd">&lt;label> &lt;span>E-mail: &lt;/span>&lt;input type="text" name="email" placeholder="Digite o seu email" />&lt;/label></span></p>
                <p><span>Manipulando os valores: </span>Para isso, aqui também vamos usar o useState, ou serja, armazenamos os valores com o set. Para isso usamos uma função no "artibuto" onChange, a função deve usar o useState para atualizar o valor do state.</p>
                <p><span>Simplificando a manipulação: </span>Podemos criar uma função inline dentro do onChange, para trocar o valor do dado de forma mais simples: <span class="cd">&lt;span>E-mail: &lt;/span>&lt;input type="text" name="email" placeholder="Digite o seu email" onChange={(e) => setEmail(e.target.value)} /></span></p>
                <p><span>Controlled inputs: </span>Podemos atribuir valores pré-existentes aos inputs dos formulários.</p>
            </div>
            <h2>Requisições HTTP no React</h2>
            <div class="revision_content">
                <p><span>JSON server: </span>Ele é um pacote npm que basicamente simula uma API, podemos fazer requisições HTTP com ele, isso facilita os estudos sem precisar de um back-end em si: <span class="cd">npm i json-server</span>. Precisamos também iniciar o servidor: <span class="cd">npm run server</span></p>
                <p><span>useEffect: </span>É um hook que nos permite controlar a execução de uma ação, se não utilizarmos esse hook alguns recursos podem ser re-executados a cada re-renderização, ou seja, a cada mudança. Ele possui um array de dependências que coordena o que permite a execução do código, ele é muito comum nas requisições HTTP.</p>
                <p><span>Resgatar dados de uma API: </span>Temos todo um procedimento para salvar e resgatar dados, primeiro usamos o useState para salvar os dados, depois temos um useEffect para chamar a API quando necessário, podemos relizar essa requisição com alguma ferramenta como Axios ou Fetch API. Para adicionar dados via API, precisamos dos inputs para preencher os useStates, após isso reunimos os dados em uma função que é disparada no evento onSubmit, utilizamos o verbo HTTP POST para isso.</p>
                <p><span>Carregamento dinâmico: </span>Se a requisição for realizada corretamente, podemos adicionar no front um novo item a lista daquela requisição, como já temos a informação dele não precisamos fazer outra requisição HTTP.</p>
                <p><span>Custom hook: </span>É normal separar as responsabilidades nos componentes, podemos criar nosso próprio hook para isso em uma pasta destinada aos hooks. Por exemplo podemos criar um hook que faça o Fetch e o POST.</p>
                <p><span>Estado de loading: </span>Quando fazemos requisições HTTP é normal que a resposta demore um pouco para chegar, esse intervalo inserimos um elemento de loading, podemos inserir ele em nosso hook.</p>
            </div>
            <h2>React Router</h2>
            <div class="revision_content">
                <p><span>React Router: </span>É o pacote mais utilizado para criar rotas em uma aplicação React. Cada rota é uma página e rota é a nomenclatura utilizada. É necessário instalar e configurar ele no projeto.</p>
                <p><span>Configurando o React Router: </span>Para configurar utilizamos o arquivo main.jsx, precisamos importar os componentes createBrowserRouter, RouterProvider e Route, eles serão utilizados na configuração e ao longo dos projetos.</p>
                <p><span>Página de erro: </span>Podemos criar uma página de erro com o router, para isso criamos um componente com nome de ErrorPage, usamos o hook useRouteError para obter informações sobre o erro, a propriedade errorElement deve ser configurada no main.jsx.</p>
                <p><span>Criando componente base: </span>Com o Outlet podemos criar componentes bases para reaproveitar a estrutura das páginas.</p>
                <p><span>Criar links entre páginas: </span>Podemos usar o componente Link, que é direto do react router, ele é configurado com a propriedade to, que leva para uma URL de destino.</p>
                <p><span>Rotas dinâmicas: </span>É assim que chamamos o recurso de carregar rotas individuais, por exemplo se temos vários produtos de um banco de dados, a URL de cada um deles varia dependendo de alguma característica dele, normalmente é o ID.</p>
                <p><span>Rotas aninhadas: </span>É uma estrutura mais complexa que combina rotas dinâmicas em uma estrutura maior para acessar a página.</p>
                <p><span>Link ativo: </span>Para identificar links ativos utilizamos o componente Navlink, em vez de Link, ou seja, na maioria das barras de navegação usamos a Navlinl e no meio da página em si utilizamos o Link.</p>
                <p><span>Search Params: </span>Ele nos permite pegar informações da URL, parecido co o hook useParams, ele é interessante para fazer funcionalidade de busca no site, o hook que utilizamos é o useSearchParams.</p>
                <p><span>Redirect: </span>Podemos criar um redirecionamento de páginas com o componente Navigate, um exemplo de uso seria quando uma URL deixa de existir mas querermos redirecionar o usuário para outra.</p>
            </div> 
        </div>
    </main>
</body>
</html>